name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Tag to use for manual release runs"
        required: true

permissions:
  contents: write

jobs:
  release_meta:
    name: Resolve release tag
    runs-on: ubuntu-latest
    outputs:
      release_tag: ${{ steps.select.outputs.release_tag }}
      publish_release: ${{ steps.select.outputs.publish_release }}
    steps:
      - name: Capture tag from push
        if: github.ref_type == 'tag'
        id: from_ref
        run: echo "release_tag=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"

      - name: Capture tag from workflow input
        if: github.event_name == 'workflow_dispatch'
        id: from_input
        env:
          INPUT_RELEASE_TAG: ${{ inputs.release_tag }}
        run: |
          if [ -z "$INPUT_RELEASE_TAG" ]; then
            echo "::error::The release_tag input is required when manually dispatching this workflow."
            exit 1
          fi
          echo "release_tag=$INPUT_RELEASE_TAG" >> "$GITHUB_OUTPUT"

      - name: Select release tag
        id: select
        run: |
          set -euo pipefail
          tag="${{ steps.from_ref.outputs.release_tag }}"
          if [ -z "$tag" ]; then
            tag="${{ steps.from_input.outputs.release_tag }}"
          fi
          if [ -z "$tag" ]; then
            echo "::error::Unable to determine release tag for this run."
            exit 1
          fi
          echo "release_tag=$tag" >> "$GITHUB_OUTPUT"
          echo "publish_release=true" >> "$GITHUB_OUTPUT"

  tests:
    name: Lint and test (Ubuntu)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache cargo builds
        uses: Swatinem/rust-cache@v2

      - name: cargo fmt
        run: cargo fmt --all --check

      - name: cargo clippy
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: cargo test
        run: cargo test --locked

  build:
    name: Build (${{ matrix.os }})
    needs:
      - tests
      - release_meta
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    env:
      RELEASE_TAG: ${{ needs.release_meta.outputs.release_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Ensure python3 alias (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $python = (Get-Command python).Source
          if (-not $python) {
            throw "python not found on PATH"
          }
          $shim = "$env:RUNNER_TEMP\python-shim"
          New-Item -ItemType Directory -Force -Path $shim | Out-Null
          Copy-Item $python "$shim\python3.exe"
          Add-Content -Path $env:GITHUB_PATH -Value $shim

      - name: Cache cargo builds
        uses: Swatinem/rust-cache@v2

      - name: cargo test
        run: cargo test --locked

      - name: Install musl target (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: rustup target add x86_64-unknown-linux-musl

      - name: Install musl tools (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: sudo apt-get update && sudo apt-get install -y musl-tools

      - name: cargo build --release (target default)
        run: cargo build --release --locked

      - name: cargo build --release (musl)
        if: matrix.os == 'ubuntu-latest'
        run: cargo build --release --locked --target x86_64-unknown-linux-musl

      - name: Package archive
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${RELEASE_TAG:-}" ]]; then
            echo "RELEASE_TAG is not set"
            exit 1
          fi
          EXT=""
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            EXT=".exe"
          fi
          TARGET_DIR="target/release"
          BIN="sv-mint${EXT}"
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            TARGET_DIR="target/x86_64-unknown-linux-musl/release"
          fi
          DIST="dist"
          rm -rf "${DIST}"
          mkdir -p "${DIST}"
          cp "${TARGET_DIR}/${BIN}" "${DIST}/${BIN}"
          cp -R docs "${DIST}/docs"
          cp -R plugins "${DIST}/plugins"
          cp sv-mint.toml "${DIST}/sv-mint.toml"
          cp README.md "${DIST}/README.md"
          cp LICENSE "${DIST}/LICENSE"
          cp CHANGELOG.md "${DIST}/CHANGELOG.md"
          ARCHIVE="sv-mint-${{ matrix.os }}-${RELEASE_TAG}"
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            (cd "${DIST}" && 7z a "../${ARCHIVE}.zip" . >/dev/null)
            ARCHIVE_PATH="${ARCHIVE}.zip"
          else
            tar -czf "${ARCHIVE}.tar.gz" -C "${DIST}" .
            ARCHIVE_PATH="${ARCHIVE}.tar.gz"
          fi
          export ARCHIVE_PATH
          python - <<'PY'
          import hashlib
          import os
          import pathlib

          path = pathlib.Path(os.environ["ARCHIVE_PATH"])
          digest = hashlib.sha256(path.read_bytes()).hexdigest()
          pathlib.Path("checksums.txt").write_text(f"{digest}  {path.name}\n")
          PY
          ls -al

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: sv-mint-${{ matrix.os }}
          path: |
            *.tar.gz
            *.zip
            checksums.txt

  release:
    name: Publish GitHub Release
    needs:
      - build
      - release_meta
    if: needs.release_meta.outputs.publish_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: release
          merge-multiple: true

      - name: Create release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.release_meta.outputs.release_tag }}
          name: sv-mint ${{ needs.release_meta.outputs.release_tag }}
          target_commitish: ${{ github.sha }}
          files: release/**
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
